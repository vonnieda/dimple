import { Button, VerticalBox , ScrollView} from "std-widgets.slint";
import { Card, CardAdapter, NeuCard } from "card.slint";
import { Styles, Navigator } from "../common.slint";
import {StyleMetrics} from "std-widgets.slint";

export struct CardGridAdapter {
    cards: [CardAdapter],
}

// TODO See: https://github.com/slint-ui/slint/discussions/4661
// TODO See: https://releases.slint.dev/1.4.1/docs/slint/src/recipes/recipes#custom-table-view
// TODO noticed that Slint 1.8.0 added ScrollView.scrolled, which I think would let me
// implement something similar to StandardTableView for scrolling long lists. 
export component CardGrid inherits VerticalBox {
    in-out property <[CardAdapter]> cards: cards_ph;

    in property <length> parent_width: 1000px;

    property <int> cols: Math.max(1, Math.floor((self.parent_width - StyleMetrics.layout-padding) 
        / (Styles.thumbnail-width-large + StyleMetrics.layout-spacing)));

    // TODO this still isn't quite right, keep ending up with hscroll. I think
    // just give up on calculating the spacing, use space-between and then
    // insert empties to fill the gap at the end.
    // property <length> col_spacing: (self.parent_width - StyleMetrics.layout-padding - StyleMetrics.layout-spacing - (cols * Styles.thumbnail-width-large)) / (cols);
    // Shit, just realized it's the genre links adding the hscroll sometimes. The above might have been working.

    spacing: StyleMetrics.layout-spacing;
    padding-right: StyleMetrics.layout-padding;
    alignment: start;
    for row in Math.ceil(cards.length / cols): HorizontalLayout {
        alignment: start;
        spacing: StyleMetrics.layout-spacing;
        for col in Math.min(cols, cards.length - (row * cols)): Card {
            model: cards[row * cols + col];
        }
    }

    property <CardAdapter> card_ph: {
        image: {image: @image-url("../../icons/phosphor/PNGs/regular/vinyl-record.png"),name: "A Reign of Fish",url: "internal://release/1234"},
        title: {name: "A Reign of Fish",url: "internal://release/1234"},
        sub-title: {name: "Fresh Pliers",url: "internal://artist/9876"},
    };

    property <[CardAdapter]> cards_ph: [card_ph, card_ph, card_ph, card_ph, card_ph];
}

component Card2 inherits Rectangle {
    border-width: 3px;
    border-color: white;
    border-radius: 16px;
    clip: true;
}

// New version of CardGrid from experiments. Calculates all positions instead of
// relying on hbox and vbox. Works great, no weirds.

export component CardGrid2 inherits ScrollView {
    in-out property <[CardAdapter]> cards;
    property <[color]> colors: [#638d5d, #838d5d, #5d8a8d, #7f5d8d, #8d6b5d, #5d648d, #8d825d];
    property <length> spacing: 16px;
    property <length> card-width: 200px;
    property <int> cols: self.width / (card-width + spacing);
    property <int> count: cards.length;
    property <length> pad: (self.width - (cols * (card-width + spacing))) / cols;

    preferred-height: Math.ceil(1.0 * count / cols) * (card-width + spacing);
    viewport-height: self.preferred-height;
    horizontal-scrollbar-policy: always-off;
    
    for i in count: Card2 {
        width: card-width;
        height: card-width; 
        property <int> roh: i / cols;
        property <int> kol: Math.mod(i, cols);
        x: kol * (card-width + (spacing + pad));
        y: roh * (card-width + spacing);
        background: colors[Math.mod(i, colors.length)];
    }
}

export component CardGrid3 inherits Rectangle {
    in-out property <[CardAdapter]> cards;
    property <[color]> colors: [#638d5d, #838d5d, #5d8a8d, #7f5d8d, #8d6b5d, #5d648d, #8d825d];
    property <length> spacing: 16px;
    in-out property <length> card-width: 200px;
    in-out property <length> card-height: 240px;
    property <int> cols: self.width / (card-width + spacing);
    property <int> count: cards.length;
    property <length> pad: (self.width - (cols * (card-width + spacing))) / cols;

    preferred-height: Math.ceil(1.0 * count / cols) * (card-width + spacing);
    
    for i in count: Card {
        model: cards[i];
        width: card-width;
        height: card-height; 
        property <int> roh: i / cols;
        property <int> kol: Math.mod(i, cols);
        x: kol * (card-width + (spacing + pad));
        y: roh * (card-height + spacing);
        // background: colors[Math.mod(i, colors.length)];
    }
}

